---
description: This rule documents how to handle OpenID Connect endpoint types in the PyWatt-Rust project, focusing on proper type handling for the CoreClient and other OIDC components.
globs: 
alwaysApply: false
---
# OpenID Connect Endpoint Types

<context>
This rule documents how to handle OpenID Connect endpoint types in the PyWatt-Rust project, focusing on proper type handling for the CoreClient and other OIDC components.
</context>

<rules>

## Endpoint Type Parameters
- OIDC clients have complex generic parameters representing endpoint configuration status
- These parameters include `HasAuthUrl`, `HasTokenUrl`, `HasUserInfoUrl`, etc.
- Client methods have different requirements for endpoint configurations
- Return types must accurately reflect the endpoint configurations

## Client Creation
- When creating a client from provider metadata with `CoreClient::from_provider_metadata`, all endpoints are properly configured
- When creating a client manually with `CoreClient::new`, endpoints must be explicitly configured
- Always test that return types match the expected endpoint configurations

## Method Requirements
- `exchange_code()` requires a properly configured token endpoint
- `authorize_url()` requires a properly configured authorization endpoint
- `user_info()` requires a properly configured user info endpoint

## Error Handling
- Type mismatches often manifest as "no method named X found for struct Y" errors
- Use consistent client creation methods to avoid endpoint type mismatches
- Provide specific error messages for endpoint configuration issues

</rules>

<patterns>

## OIDC Client Creation with Discovery
```rust
// Recommended approach: Use discovery to ensure all endpoints are configured
let issuer_url = IssuerUrl::new("https://accounts.google.com".to_string())?;
let provider_metadata = CoreProviderMetadata::discover_async(
    issuer_url, 
    oidc_async_http_client
).await?;

let client = CoreClient::from_provider_metadata(
    provider_metadata,
    client_id,
    Some(client_secret),
)
.set_redirect_uri(redirect_url);
```

## OIDC Client Creation with Manual Configuration
```rust
// Alternative approach: Manually configure all required endpoints
let client = CoreClient::new(
    client_id,
    Some(client_secret),
    auth_url,
    token_url,
    None, // Optional token introspection endpoint
    None, // Optional device authorization endpoint
    None, // Optional revocation endpoint
)
.set_redirect_uri(redirect_url)
.set_user_info_url(user_info_url);
```

## Authorization URL Generation
```rust
// Generate authorization URL with PKCE
let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
let state = CsrfToken::new_random();
let nonce = Nonce::new_random();

// Use AuthenticationFlow to ensure proper type parameters
let auth_url = client
    .authorize_url(
        AuthenticationFlow::<CoreResponseType>::AuthorizationCode, 
        || state.clone(),  // Use closure syntax
        || nonce.clone()   // Use closure syntax
    )
    .set_pkce_challenge(pkce_challenge)
    .add_scope(Scope::new("profile".to_string()))
    .add_scope(Scope::new("email".to_string()))
    .url();
```

## Token Exchange
```rust
// Exchange code for tokens
let token_response = client
    .exchange_code(AuthorizationCode::new(code))
    .set_pkce_verifier(pkce_verifier)
    .request_async(oidc_async_http_client)
    .await?;

// Access ID token and verify it
let id_token = token_response.id_token()
    .ok_or_else(|| AppError::OAuthError("No ID token in response".to_string()))?;

let claims = id_token.claims(&client.id_token_verifier(), &nonce)?;
```

## User Info Retrieval
```rust
// Get provider metadata to access user info endpoint
if let Some(provider_metadata) = client.provider_metadata() {
    if let Some(userinfo_url) = provider_metadata.userinfo_endpoint() {
        // Create client with user info URL properly set
        let userinfo_client = client.clone()
            .set_user_info_url(userinfo_url.clone());
        
        // Request user info
        let userinfo = userinfo_client
            .user_info(
                token_response.access_token().clone(),
                None
            )
            .request_async(oidc_async_http_client)
            .await?;
            
        // Process user info
        // ...
    }
}
```

</patterns>

<examples>

## Complete OIDC Flow
```rust
pub async fn authenticate_with_oidc(
    provider: &str,
    code: &str,
    state: &str,
    saved_state: &str,
    pkce_verifier: PkceCodeVerifier,
    nonce: Nonce,
) -> AppResult<UserInfo> {
    // Verify state to prevent CSRF
    if state != saved_state {
        return Err(AppError::InvalidRequest("State mismatch".to_string()));
    }
    
    // Create OIDC client with discovery
    let issuer_url = IssuerUrl::new("https://accounts.google.com".to_string())?;
    let provider_metadata = CoreProviderMetadata::discover_async(
        issuer_url, 
        oidc_async_http_client
    ).await?;
    
    let client = CoreClient::from_provider_metadata(
        provider_metadata,
        OidcClientId::new(client_id),
        Some(OidcClientSecret::new(client_secret)),
    )
    .set_redirect_uri(OidcRedirectUrl::new(redirect_uri)?);
    
    // Exchange code for tokens
    let token_response = client
        .exchange_code(AuthorizationCode::new(code.to_string()))
        .set_pkce_verifier(pkce_verifier)
        .request_async(oidc_async_http_client)
        .await?;
    
    // Verify ID token
    let id_token = token_response.id_token()
        .ok_or_else(|| AppError::OAuthError("No ID token in response".to_string()))?;
    
    let claims = id_token.claims(&client.id_token_verifier(), &nonce)?;
    
    // Extract basic user info from claims
    let user_info = UserInfo {
        id: claims.subject().to_string(),
        email: claims.email().map(|e| e.to_string()),
        name: claims.name().map(|n| n.to_string()),
        picture: claims.picture().map(|p| p.to_string()),
    };
    
    // Get additional info from userinfo endpoint if available
    if let Some(provider_metadata) = client.provider_metadata() {
        if let Some(userinfo_url) = provider_metadata.userinfo_endpoint() {
            let userinfo_client = client.clone()
                .set_user_info_url(userinfo_url.clone());
            
            if let Ok(additional_info) = userinfo_client
                .user_info(token_response.access_token().clone(), None)
                .request_async(oidc_async_http_client)
                .await
            {
                // Combine with additional user info if needed
                // ...
            }
        }
    }
    
    Ok(user_info)
}
```

## Fixing Common Type Issues
```rust
// ❌ INCORRECT: Return types don't match, metadata configures all endpoints
pub async fn create_oidc_client() -> AppResult<CoreClient> {
    // ... discovery code ...
    
    let client = CoreClient::from_provider_metadata(
        provider_metadata,
        client_id,
        Some(client_secret),
    )
    .set_redirect_uri(redirect_url);
    
    // This client has all endpoints configured (EndpointSet)
    // but the function signature expects EndpointNotSet
    Ok(client)
}

// ✅ CORRECT: Return type reflects actual endpoint configuration
pub async fn create_oidc_client() -> AppResult<CoreClient> {
    // ... discovery code ...
    
    let client = CoreClient::from_provider_metadata(
        provider_metadata,
        client_id,
        Some(client_secret),
    )
    .set_redirect_uri(redirect_url);
    
    Ok(client)
}

// Alternatively, specify the exact type parameters in the return type
pub async fn create_oidc_client() -> AppResult<openidconnect::Client<
    _, _, _, _, _, _,
    _, _, _, _, _,
    openidconnect::EndpointSet, // Auth URL is set
    _, _, _,
    openidconnect::EndpointSet, // Token URL is set
    openidconnect::EndpointMaybeSet // UserInfo URL may be set
>> {
    // ... client creation code ...
}
```

</examples>

<common_issues>

## "No Method Named X Found" Errors
```rust
// Error: no method named `exchange_code` found for struct `CoreClient<...>`
// Cause: Client doesn't have token endpoint configured
let token_response = client
    .exchange_code(code)  // ❌ ERROR: No token endpoint
    .request_async(oidc_async_http_client)
    .await?;

// Solution: Ensure client is created with token endpoint
let client = CoreClient::from_provider_metadata(
    provider_metadata,  // ✅ Discovery ensures token endpoint is set
    client_id,
    Some(client_secret)
);
```

## "No Method Named authorize_url Found" Errors
```rust
// Error: no method named `authorize_url` found for struct `CoreClient<...>`
// Cause: Client doesn't have auth endpoint configured
let auth_url = client
    .authorize_url(  // ❌ ERROR: No auth endpoint
        AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
        || state.clone(),
        || nonce.clone()
    )
    .url();

// Solution: Ensure client is created with auth endpoint
let client = CoreClient::from_provider_metadata(
    provider_metadata,  // ✅ Discovery ensures auth endpoint is set
    client_id,
    Some(client_secret)
);
```

## Type Mismatch Errors
```rust
// Error: expected `EndpointNotSet`, found `EndpointSet`
// Cause: Function signature doesn't match actual client configuration
pub async fn create_client() -> AppResult<CoreClient<..., EndpointNotSet, ...>> {
    let client = CoreClient::from_provider_metadata(
        provider_metadata,  // This configures endpoints as EndpointSet
        client_id,
        Some(client_secret)
    );
    
    Ok(client)  // ❌ ERROR: Type mismatch
}

// Solution: Fix function signature to match actual configuration
pub async fn create_client() -> AppResult<CoreClient> {  // ✅ Let Rust infer exact type
    // ... same code ...
}
```

## Provider Metadata Access Errors
```rust
// Error: no method named `provider_metadata` found for reference `&CoreClient<...>`
// Cause: Client wasn't created from provider metadata
let provider_metadata = client.provider_metadata()  // ❌ ERROR

// Solution: Use client created from provider metadata
let client = CoreClient::from_provider_metadata(
    provider_metadata,
    client_id,
    Some(client_secret)
);

// Now this works
if let Some(metadata) = client.provider_metadata() {  // ✅ Works
    // ...
}
```

</common_issues>

<troubleshooting>

## Common Error Messages and Solutions

### "No Method Named X Found" Errors
- **Error**: "no method named `exchange_code` found for struct `Client<...>`"
- **Cause**: Token endpoint not configured on client
- **Solution**: Use discovery to ensure all endpoints are configured

### "Expected EndpointNotSet, Found EndpointSet" Errors
- **Error**: "expected `EndpointNotSet`, found `EndpointSet`"
- **Cause**: Function signature doesn't match actual client configuration
- **Solution**: Update function signature to match or let Rust infer the type

### "No Provider Metadata Available" Errors
- **Error**: "no method named `provider_metadata` found"
- **Cause**: Client wasn't created using `from_provider_metadata`
- **Solution**: Create client using discovery and `from_provider_metadata`

## Debugging Tips
- Use log statements to track client creation and endpoint status
- Check error messages carefully for type mismatch details
- Add explicit type annotations for clarity when debugging
- Test in isolation with simpler client configurations
- Use `.clone()` when extending clients to avoid reference issues

</troubleshooting>
