---
description: The configuration management system provides a flexible, layered approach to managing application settings. It supports multiple configuration sources (environment variables, files) and provides strongly-typed settings with validation and default values.
globs: 
alwaysApply: false
---
# Configuration Management

## Purpose
The configuration management system provides a flexible, layered approach to managing application settings. It supports multiple configuration sources (environment variables, files) and provides strongly-typed settings with validation and default values.

## Key Types & Structures
```rust
pub struct Settings {
    // Server Configuration
    pub application_port: u16,
    pub application_url: String,
    
    // Database Configuration
    pub database: DatabaseSettings,
    
    // Authentication & Security
    pub jwt: JwtSettings,
    pub token: TokenSettings,
    pub totp: TotpSettings,
    pub oauth: OAuthSettings,
    
    // Email & Communication
    pub email: EmailSettings,
    pub email_verification: EmailVerificationSettings,
    
    // Security & Rate Limiting
    pub rate_limit: RateLimitSettings,
    pub account_locking: AccountLockingSettings,
    pub cors: CorsSettings,
    pub security: SecuritySettings,
    
    // Caching & State
    pub redis_url: String,
    pub skip_redis_connection: bool,
    
    // AI & Machine Learning
    pub llm: LlmSettings,
    pub memory: MemorySettings,
    
    // Storage
    pub storage: StorageSettings,
}

pub struct DatabaseSettings {
    pub url: String,
    pub skip_db_connection: bool,
}

pub struct JwtSettings {
    pub access_token_secret: String,
    pub access_token_expires_in: i64,
    pub refresh_token_secret: String,
    pub refresh_token_expires_in: i64,
}

// ... other settings structures
```

## Design Patterns
### Builder Pattern
- **Purpose**: Constructs settings with layered configuration
- **Implementation**: Uses `config` crate's builder pattern
- **Usage**: Loads settings from multiple sources in priority order

### Default Implementations
- **Purpose**: Provides sensible defaults for optional settings
- **Implementation**: Implements `Default` trait for settings structs
- **Usage**: Default values are used when settings are not explicitly provided

### Type-Safe Configuration
- **Purpose**: Ensures configuration values are valid at compile time
- **Implementation**: Uses strongly-typed structs with validation
- **Usage**: Settings are deserialized into typed structures

## Error Handling
### Error Types
```rust
pub enum ConfigError {
    // From config crate
    NotFound(String),
    InvalidType(String, &'static str, String),
    // ... other variants
}
```

### Error Propagation
- Configuration errors are propagated during startup
- Invalid configurations prevent application startup
- Validation errors provide detailed error messages

## Usage Examples
```rust
// Loading configuration
impl Settings {
    pub fn new() -> Result<Self, ConfigError> {
        let env = env::var("APP_ENV").unwrap_or_else(|_| "development".into());
        
        Config::builder()
            .add_source(File::with_name("config/default"))
            .add_source(File::with_name(&format!("config/{}", env)).required(false))
            .add_source(Environment::with_prefix("APP"))
            .build()?
            .try_deserialize()
    }
}

// Using settings in services
pub struct AuthService {
    jwt_settings: Arc<JwtSettings>,
    // ...
}

impl AuthService {
    pub fn new(settings: Arc<Settings>) -> Self {
        Self {
            jwt_settings: Arc::new(settings.jwt.clone()),
            // ...
        }
    }
}
```

## Testing Approach
### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_default_settings() {
        let settings = Settings::default();
        assert_eq!(settings.application_port, 8080);
        // ... other assertions
    }
    
    #[test]
    fn test_env_override() {
        std::env::set_var("APP_APPLICATION_PORT", "9000");
        let settings = Settings::new().unwrap();
        assert_eq!(settings.application_port, 9000);
    }
}
```

### Integration Tests
- Test configuration loading from files
- Validate environment variable overrides
- Test configuration validation rules

## Dependencies
### Internal Dependencies
- None (root level configuration)

### External Dependencies
- `config`: Configuration management
- `serde`: Serialization/deserialization
- `secrecy`: Secure string handling
- `dirs`: Default path resolution

## Notes & Best Practices
### Performance Considerations
- Configuration is loaded once at startup
- Settings are shared via `Arc` to avoid cloning
- Validation is performed at load time

### Security Considerations
- Sensitive values use `Secret<String>`
- Environment variables can override file settings
- Secrets are never logged or serialized

### Rust Idioms
- Use of `Option<T>` for optional settings
- Implementation of `Default` trait
- Builder pattern for configuration

### Maintenance Notes
- Document all configuration options
- Keep default values reasonable
- Consider backward compatibility
- Use feature flags for optional features

## Related Components
- `AppState`: Application state management
- `Services`: Service initialization
- `.env`: Environment variable examples
- `config/*`: Configuration files
