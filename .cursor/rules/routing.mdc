---
description: The routing system defines the API endpoints and their handlers, organizing them into logical groups based on functionality. It implements a layered middleware approach for authentication, authorization, and request processing.
globs: 
alwaysApply: false
---
# Routing System

## Purpose
The routing system defines the API endpoints and their handlers, organizing them into logical groups based on functionality. It implements a layered middleware approach for authentication, authorization, and request processing.

## Key Types & Structures
```rust
// Route Groups
pub struct Router {
    // Core Routes
    health: Router,
    auth: Router,
    users: Router,
    permissions: Router,
    
    // API Management
    api_keys: Router,
    config: Router,
    
    // Business Logic
    customers: Router,
    products: Router,
    invoices: Router,
    payments: Router,
    estimates: Router,
    subscriptions: Router,
    
    // Chat & Documents
    conversations: Router,
    documents: Router,
    
    // WebSocket
    ws: Router,
    
    // Session Management
    session: Router,
    
    // Security
    totp: Router,
}

// Route Handler Types
type AuthenticatedHandler<T> = impl Handler<T, AppState>;
type PublicHandler<T> = impl Handler<T>;
```

## Design Patterns
### Route Organization
- **Purpose**: Groups related endpoints logically
- **Implementation**: Modular router construction
- **Usage**: Routes are organized by domain/feature

### Middleware Layers
- **Purpose**: Applies cross-cutting concerns
- **Implementation**: Uses tower middleware stack
- **Usage**: Authentication, logging, rate limiting

### Handler Extraction
- **Purpose**: Type-safe request handling
- **Implementation**: Uses Axum extractors
- **Usage**: Extracts and validates request data

## Route Categories
### Public Routes
```rust
// Health check and public auth endpoints
pub fn public_routes(state: AppState) -> Router {
    Router::new()
        .route("/health", get(health_check))
        .nest("/auth", auth::public_routes(state))
}
```

### Authenticated Routes
```rust
// Routes requiring authentication
pub fn authenticated_routes(state: AppState) -> Router {
    Router::new()
        .nest("/users", users::routes(state))
        .nest("/api-keys", api_keys::routes(state))
        .nest("/conversations", conversations::routes(state))
        .route_layer(middleware::from_fn_with_state(state, auth_guard))
}
```

### Admin Routes
```rust
// Routes requiring admin privileges
pub fn admin_routes(state: AppState) -> Router {
    Router::new()
        .nest("/admin", admin::routes(state))
        .route_layer(middleware::from_fn_with_state(state.clone(), require_admin))
        .route_layer(middleware::from_fn_with_state(state, auth_guard))
}
```

## Usage Examples
```rust
// Route Handler Example
async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUser>,
) -> Result<impl IntoResponse, AppError> {
    let user = state.user_service.create_user(payload).await?;
    Ok((StatusCode::CREATED, Json(user)))
}

// WebSocket Handler
async fn ws_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(|socket| handle_socket(socket, state))
}

// Protected Route with Role Check
async fn admin_action(
    claims: Claims,
    State(state): State<AppState>,
) -> Result<impl IntoResponse, AppError> {
    require_permission(&claims, "admin.action")?;
    // Handler logic...
}
```

## Testing Approach
### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_health_check() {
        let app = create_test_app().await;
        let response = app
            .oneshot(Request::builder().uri("/health").body(Body::empty()).unwrap())
            .await
            .unwrap();
        
        assert_eq!(response.status(), StatusCode::OK);
    }
}
```

### Integration Tests
- Test middleware stack behavior
- Validate authentication flows
- Test rate limiting and security
- WebSocket connection testing

## Dependencies
### Internal Dependencies
- `services/*`: Business logic
- `middleware/*`: Request processing
- `models/*`: Data structures
- `errors.rs`: Error handling

### External Dependencies
- `axum`: Web framework
- `tower`: Middleware
- `tower-http`: HTTP-specific middleware
- `axum-extra`: Additional extractors

## Notes & Best Practices
### Performance Considerations
- Use appropriate extractors
- Implement caching where needed
- Consider response streaming
- WebSocket message batching

### Security Considerations
- Proper authentication checks
- CSRF protection
- Rate limiting
- Input validation

### Rust Idioms
- Type-safe routing
- Error type propagation
- Async handler patterns
- Extractor implementations

### Maintenance Notes
- Document new routes
- Consider API versioning
- Maintain OpenAPI specs
- Monitor deprecated routes

## Related Components
- `middleware/*`: Request processing
- `handlers/*`: Route handlers
- `services/*`: Business logic
- `models/*`: Request/response types
