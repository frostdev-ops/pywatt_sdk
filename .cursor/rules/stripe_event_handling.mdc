---
description: This rule documents the pattern for handling Stripe webhook events in the `finance_service` module's `main.rs` file, specifically within the `handle_stripe_webhook` Axum handler.
globs: 
alwaysApply: false
---
# Cursor Rule: stripe_event_handling

<context>
This rule documents the pattern for handling Stripe webhook events in the `finance_service` module's `main.rs` file, specifically within the `handle_stripe_webhook` Axum handler.
</context>

<rules>

## Handler Logic

1.  **Signature Verification**: 
    - Extracts the `Stripe-Signature` header.
    - Calls `StripeService::verify_webhook` with the raw request body (`Bytes`) and the signature header.
    - Handles potential `Err` from verification (e.g., invalid signature, payload issues) by returning `StatusCode::BAD_REQUEST`.
2.  **Event Deserialization**: If verification succeeds, `verify_webhook` returns a `stripe::Event`.
3.  **Event Type Matching**: 
    - The handler uses a `match` statement on the `event.type_` field, which is of type `stripe::EventType`.
    - **Do not** compare `event.type_` against string literals (e.g., `"checkout.session.completed"`). Use the enum variants directly (e.g., `EventType::CheckoutSessionCompleted`).
4.  **Processing Specific Events**: 
    - Inside the `match` arms, handle specific event types.
    - For events containing relevant objects (like `CheckoutSessionCompleted`), destructure `event.data.object` using `if let EventObject::CheckoutSession(session) = event.data.object { ... }`.
    - Extract necessary data from the event object (e.g., `session.client_reference_id`).
    - Perform business logic (e.g., update database records, trigger other services).
5.  **Logging**: Log received events, successful processing, and any errors encountered.
6.  **Response**: Return `StatusCode::OK` on successful receipt and basic processing of the event (even if internal business logic fails, Stripe only needs confirmation of receipt). Return appropriate error codes (4xx/5xx) only if the webhook request itself is invalid or cannot be processed at all.
## Example (`handle_stripe_webhook`)

```rust
use axum::{
    extract::State,
    http::{StatusCode, HeaderMap},
    response::IntoResponse,
    body::Bytes,
};
use stripe::{Event, EventObject, EventType}; // Ensure EventType is imported
use uuid::Uuid;
use tracing::{info, error, debug};

// Assuming AppState and relevant services (StripeService, InvoiceService, PaymentService) exist

async fn handle_stripe_webhook(State(state): State<AppState>, headers: HeaderMap, body: Bytes) -> impl IntoResponse {
    let sig = headers.get("stripe-signature").and_then(|v| v.to_str().ok()).unwrap_or("");
    
    match state.stripe_service.verify_webhook(&body, sig) {
        Ok(event) => {
            info!(event_type=?event.type_, "Received Stripe webhook");
            
            match event.type_ {
                EventType::CheckoutSessionCompleted => {
                    if let EventObject::CheckoutSession(session) = event.data.object {
                        if let Some(ref_id_str) = &session.client_reference_id {
                            if let Ok(invoice_id) = Uuid::parse_str(ref_id_str) {
                                info!(invoice_id=%invoice_id, "Processing CheckoutSessionCompleted");
                                // ... business logic to update invoice/payment status ...
                            } else {
                                error!(client_ref_id=%ref_id_str, "Failed to parse Uuid from client_reference_id");
                            }
                        } else {
                             warn!(session_id=%session.id, "Missing client_reference_id in CheckoutSessionCompleted");
                        }
                    }
                }
                EventType::CheckoutSessionAsyncPaymentSucceeded => {
                    info!(event_id=%event.id, "Received CheckoutSessionAsyncPaymentSucceeded");
                    // ... handle async success ...
                }
                // ... handle other event types ...
                _ => {
                    debug!(event_type=?event.type_, "Unhandled Stripe event type");
                }
            }
            
            StatusCode::OK.into_response()
        }
        Err(e) => {
            error!(error=%e, "Invalid Stripe webhook signature or payload");
            (StatusCode::BAD_REQUEST, format!("Webhook Error: {}", e)).into_response()
        }
    }
}
```

## Key Points

- Always verify webhook signatures.
- Use `match event.type_ { EventType::Variant => ... }` for routing.
- Extract data using `if let EventObject::RelevantType(data) = event.data.object { ... }`.
- Respond promptly with `StatusCode::OK` to acknowledge receipt to Stripe.
- Handle business logic failures asynchronously or gracefully without blocking the webhook response if possible.

</rules> 
