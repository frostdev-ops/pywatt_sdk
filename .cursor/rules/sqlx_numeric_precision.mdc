---
description: This rule documents best practices for handling numeric precision in SQLx queries, focusing on proper type handling for float and decimal values.
globs: 
alwaysApply: false
---
# SQLx Numeric Precision

<context>
This rule documents best practices for handling numeric precision in SQLx queries, focusing on proper type handling for float and decimal values.
</context>

<rules>

## Float Type Casting
- Always use explicit type casting for float values when retrieving from the database
- Use `::float8` for f64 values in query_as! and query_scalar! macros
- Use `::float4` for f32 values in query_as! and query_scalar! macros
- Always include these casts in RETURNING clauses when inserting or updating data

## Decimal Type Handling
- For Decimal fields, use `::numeric` type casting in SQL queries
- Always specify numeric precision explicitly when creating tables
- For money calculations, use `NUMERIC(19,4)` or similar with adequate precision
- Ensure model structures use the appropriate Rust type (sqlx::types::BigDecimal)

## NULL Value Handling
- Use `COALESCE()` for handling NULL numeric values in SQL
- For aggregate functions like SUM, always handle NULL cases with COALESCE
- When optional numeric values are expected, use Option<T> in Rust models

## Numeric Comparison
- Be aware of floating point precision issues when comparing values
- For exact comparisons where precision matters, use Decimal instead of f64/f32
- Use appropriate epsilon values when comparing floats for equality

</rules>

<patterns>

## Float Type Casting in Queries
```rust
// Query a single record with float values
let item = sqlx::query_as!(
    Item,
    r#"
    SELECT 
        id, name, price::float8, quantity, 
        weight::float8, height::float8, length::float8
    FROM items
    WHERE id = $1
    "#,
    id
)
.fetch_one(&*pool)
.await?;
```

## Inserting and Returning Float Values
```rust
// Insert a record and return with properly cast float values
let item = sqlx::query_as!(
    Item,
    r#"
    INSERT INTO items (name, price, weight)
    VALUES ($1, $2, $3)
    RETURNING 
        id, name, price::float8, quantity, 
        weight::float8, height::float8, length::float8
    "#,
    name,
    price,
    weight
)
.fetch_one(&*pool)
.await?;
```

## Updating and Returning Float Values
```rust
// Update a record and return with properly cast float values
let updated_item = sqlx::query_as!(
    Item,
    r#"
    UPDATE items
    SET price = $2, weight = $3
    WHERE id = $1
    RETURNING 
        id, name, price::float8, quantity, 
        weight::float8, height::float8, length::float8
    "#,
    id,
    new_price,
    new_weight
)
.fetch_one(&*pool)
.await?;
```

## Handling NULL Values with COALESCE
```rust
// Calculate total with NULL handling
let result = sqlx::query!(
    r#"
    SELECT COALESCE(SUM(price * quantity), 0.0)::float8 as total
    FROM items
    WHERE category_id = $1
    "#,
    category_id
)
.fetch_one(&*pool)
.await?;

let total = result.total;
```

</patterns>

<examples>

## Complete CRUD Example with Float Handling
```rust
pub struct ProductService {
    pool: Arc<PgPool>,
}

impl ProductService {
    pub fn new(pool: Arc<PgPool>) -> Self {
        Self { pool }
    }
    
    // Create a product with proper float handling
    pub async fn create_product(
        &self,
        name: String,
        price: f64,
        weight: Option<f64>,
    ) -> AppResult<Product> {
        let product = sqlx::query_as!(
            Product,
            r#"
            INSERT INTO products (name, price, weight)
            VALUES ($1, $2, $3)
            RETURNING 
                id, name, price::float8, weight::float8, 
                created_at, updated_at
            "#,
            name,
            price,
            weight,
        )
        .fetch_one(&*self.pool)
        .await?;
        
        Ok(product)
    }
    
    // Get a product with proper float handling
    pub async fn get_product(&self, id: Uuid) -> AppResult<Product> {
        let product = sqlx::query_as!(
            Product,
            r#"
            SELECT 
                id, name, price::float8, weight::float8, 
                created_at, updated_at
            FROM products
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&*self.pool)
        .await?
        .ok_or_else(|| AppError::NotFound("Product not found".to_string()))?;
        
        Ok(product)
    }
    
    // Update a product with proper float handling
    pub async fn update_product(
        &self,
        id: Uuid,
        name: Option<String>,
        price: Option<f64>,
        weight: Option<f64>,
    ) -> AppResult<Product> {
        let product = sqlx::query_as!(
            Product,
            r#"
            UPDATE products
            SET 
                name = COALESCE($2, name),
                price = COALESCE($3, price),
                weight = COALESCE($4, weight),
                updated_at = NOW()
            WHERE id = $1
            RETURNING 
                id, name, price::float8, weight::float8, 
                created_at, updated_at
            "#,
            id,
            name,
            price,
            weight,
        )
        .fetch_one(&*self.pool)
        .await?;
        
        Ok(product)
    }
    
    // Calculate total price with proper float handling
    pub async fn calculate_total_price(&self, ids: &[Uuid]) -> AppResult<f64> {
        if ids.is_empty() {
            return Ok(0.0);
        }
        
        // Using ANY with array for multiple IDs
        let result = sqlx::query!(
            r#"
            SELECT COALESCE(SUM(price), 0.0)::float8 as total
            FROM products
            WHERE id = ANY($1)
            "#,
            ids as &[Uuid],
        )
        .fetch_one(&*self.pool)
        .await?;
        
        Ok(result.total)
    }
}
```

## Aggregate Function with Float Handling
```rust
pub async fn get_product_stats(&self, category_id: Uuid) -> AppResult<ProductStats> {
    let stats = sqlx::query_as!(
        ProductStats,
        r#"
        SELECT 
            COUNT(*) as "count!",
            MIN(price)::float8 as "min_price!",
            MAX(price)::float8 as "max_price!",
            AVG(price)::float8 as "avg_price!",
            PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY price)::float8 as "median_price!"
        FROM products
        WHERE category_id = $1
        "#,
        category_id
    )
    .fetch_one(&*self.pool)
    .await?;
    
    Ok(stats)
}
```

</examples>

<common_issues>

## Missing Type Casting
```rust
// ❌ INCORRECT: Missing float casting
let product = sqlx::query_as!(
    Product,
    r#"
    SELECT id, name, price, weight
    FROM products
    WHERE id = $1
    "#,
    id
)
.fetch_one(&*pool)
.await?;

// ✅ CORRECT: With proper float casting
let product = sqlx::query_as!(
    Product,
    r#"
    SELECT id, name, price::float8, weight::float8
    FROM products
    WHERE id = $1
    "#,
    id
)
.fetch_one(&*pool)
.await?;
```

## Incorrect NULL Handling
```rust
// ❌ INCORRECT: No NULL handling for aggregate function
let result = sqlx::query!(
    r#"
    SELECT SUM(price) as total
    FROM products
    WHERE category_id = $1
    "#,
    category_id
)
.fetch_one(&*pool)
.await?;

// This might be NULL if there are no products!
let total = result.total;

// ✅ CORRECT: With NULL handling using COALESCE
let result = sqlx::query!(
    r#"
    SELECT COALESCE(SUM(price), 0.0)::float8 as total
    FROM products
    WHERE category_id = $1
    "#,
    category_id
)
.fetch_one(&*pool)
.await?;

// This will never be NULL
let total = result.total;
```

## Missing Cast in RETURNING Clause
```rust
// ❌ INCORRECT: Missing float casting in RETURNING
let product = sqlx::query_as!(
    Product,
    r#"
    INSERT INTO products (name, price)
    VALUES ($1, $2)
    RETURNING id, name, price, created_at, updated_at
    "#,
    name,
    price
)
.fetch_one(&*pool)
.await?;

// ✅ CORRECT: With float casting in RETURNING
let product = sqlx::query_as!(
    Product,
    r#"
    INSERT INTO products (name, price)
    VALUES ($1, $2)
    RETURNING id, name, price::float8, created_at, updated_at
    "#,
    name,
    price
)
.fetch_one(&*pool)
.await?;
```

</common_issues>

<troubleshooting>

## Common Error Messages

### Type Mismatch Errors
- **Error**: "expected `f64`, found `PgNumeric`"
- **Cause**: Missing `::float8` cast in SQL query
- **Solution**: Add explicit `::float8` cast to the column

### NULL Value Errors
- **Error**: "expected `f64`, found `null`"
- **Cause**: NULL value in database for a non-Option field in Rust
- **Solution**: Use `COALESCE()` in SQL or make the field `Option<f64>` in Rust

### Precision Loss Warnings
- **Warning**: "possible loss of precision when converting between decimal types"
- **Cause**: Converting between numeric types with different precision
- **Solution**: Use types with appropriate precision or explicit casts

## General Solutions
- Always use explicit casts in SQL queries
- Handle NULL values with COALESCE or Option types
- Use Decimal for financial calculations instead of floating point
- Add comprehensive tests for numeric calculations and edge cases

</troubleshooting>
