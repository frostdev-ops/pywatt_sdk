---
description: This rule documents the OAuth and OpenID Connect (OIDC) integration patterns in the PyWatt-Rust project, including best practices for handling authentication flows, token exchange, and user information retrieval.
globs: 
alwaysApply: false
---
# OAuth Implementation Patterns

<context>
This rule documents the OAuth and OpenID Connect (OIDC) integration patterns in the PyWatt-Rust project, including best practices for handling authentication flows, token exchange, and user information retrieval.
</context>

<rules>

## Client Setup
- Use appropriate client types for different providers (`BasicClient` for OAuth2, `CoreClient` for OIDC)
- Always ensure OAuth2 clients have auth and token endpoints properly set
- For OIDC clients, use provider metadata discovery when available
- Always provide redirect URLs
- Store provider settings in a central configuration

## Authorization Flows
- Use PKCE (Proof Key for Code Exchange) for all OAuth flows to prevent authorization code interception attacks
- Generate and validate CSRF tokens (state parameter) to prevent cross-site request forgery
- For OIDC, always generate and validate a nonce value
- Handle query parameters correctly in redirect URIs

## Token Exchange
- Properly handle token exchange errors with detailed logging
- For OIDC, validate ID tokens (signature, issuer, audience, expiration)
- Verify access token hash in ID tokens when available
- Extract and store refresh tokens when available

## User Information
- Use provider-specific user info endpoints correctly
- Handle different response formats from different providers
- Normalize user information from different providers into a common format
- Implement proper error handling for user info retrieval

## Error Handling
- Use specific error types for different OAuth failure modes
- Log detailed error information but return sanitized errors to users
- Add proper instrumentation with request IDs for tracing

</rules>

<patterns>

## OAuth2 Client Setup
```rust
let client = BasicClient::new(
    ClientId::new(client_id),
    Some(ClientSecret::new(client_secret)),
    AuthUrl::new(auth_url)?,
    Some(TokenUrl::new(token_url)?),
)
.set_redirect_uri(RedirectUrl::new(redirect_uri)?);
```

## OIDC Client Setup with Provider Discovery
```rust
// Fetch provider metadata
let provider_metadata = CoreProviderMetadata::discover_async(
    IssuerUrl::new(issuer_url)?, 
    oidc_async_http_client
).await?;

// Create client with metadata
let client = CoreClient::from_provider_metadata(
    provider_metadata,
    OidcClientId::new(client_id),
    Some(OidcClientSecret::new(client_secret)),
)
.set_redirect_uri(OidcRedirectUrl::new(redirect_uri)?);
```

## Authorization URL Generation
```rust
// OAuth2
let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
let state = CsrfToken::new_random();

let auth_url = client.authorize_url(|| state.clone())
    .set_pkce_challenge(pkce_challenge)
    .add_scope(Scope::new("profile".to_string()))
    .add_scope(Scope::new("email".to_string()))
    .url();

// OIDC
let nonce = Nonce::new_random();
let auth_url = client.authorize_url(
    AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
    || state.clone(),
    || nonce.clone()
)
.set_pkce_challenge(pkce_challenge)
.url();
```

## Token Exchange
```rust
// OAuth2
let token_response = client
    .exchange_code(code)
    .set_pkce_verifier(pkce_verifier)
    .request_async(async_http_client)
    .await?;

// OIDC
let token_response = client
    .exchange_code(code)
    .set_pkce_verifier(pkce_verifier)
    .request_async(oidc_async_http_client)
    .await?;

// Verify ID token (OIDC)
let id_token = token_response.id_token()
    .ok_or_else(|| AppError::OAuthCodeExchangeFailed("No ID token in response".to_string()))?;

let claims = id_token.claims(&client.id_token_verifier(), &nonce)?;
```

## Access Token Hash Verification (OIDC)
```rust
if let Some(expected_hash) = claims.access_token_hash() {
    let signing_alg = id_token.signing_alg()?;
    // Need to provide a key for the hash function, but it's not actually used
    let key_dummy = CoreJsonWebKey::new(serde_json::Value::Null);
    let actual_hash = AccessTokenHash::from_token(
        token_response.access_token(), 
        &signing_alg,
        &key_dummy
    )?;
    
    if actual_hash != *expected_hash {
        return Err(AppError::InvalidToken("Access token hash mismatch".to_string()));
    }
}
```

## User Info Retrieval (OIDC)
```rust
if let Some(userinfo_endpoint) = client.userinfo_endpoint() {
    let request = userinfo_endpoint.request(
        token_response.access_token().clone(),
        None
    );
    
    let userinfo = request.request_async(oidc_async_http_client).await?;
    // Process user info
}
```

## Provider-Specific User Info (OAuth2)
```rust
// GitHub example
let response = reqwest::Client::new()
    .get("https://api.github.com/user")
    .bearer_auth(access_token)
    .send()
    .await?;

if response.status().is_success() {
    let user_info: HashMap<String, serde_json::Value> = response.json().await?;
    // Process user info
}
```

</patterns>

<examples>

## Complete OAuth2 Flow Example
```rust
// 1. Generate authorization URL
let (auth_url, state, pkce_verifier) = generate_auth_parameters("github", &settings).await?;

// 2. User visits auth_url and grants permission
// 3. Provider redirects to your callback URL with a code and state

// 4. Verify state matches to prevent CSRF
if received_state != state.secret() {
    return Err(AppError::InvalidToken("OAuth state mismatch".to_string()));
}

// 5. Exchange code for tokens
let code = AuthorizationCode::new(received_code.to_string());
let token_response = exchange_oauth2_code(
    "github", 
    client, 
    code, 
    pkce_verifier
).await?;

// 6. Get user information
let user_info = fetch_github_user_info(token_response.access_token().secret()).await?;

// 7. Create or update user record
let email = user_info.get("email")
    .and_then(|v| v.as_str())
    .ok_or_else(|| AppError::OAuthUserInfoFailed("Missing email".to_string()))?;

let user = user_service.find_or_create_oauth_user(
    "github",
    user_info.get("id").unwrap().as_u64().unwrap().to_string(),
    email.to_string(),
    user_info.get("name").and_then(|v| v.as_str()).map(|s| s.to_string()),
).await?;
```

## Complete OIDC Flow Example
```rust
// 1. Generate authorization URL with nonce
let (auth_url, state, pkce_verifier, Some(nonce)) = 
    generate_auth_parameters("google", &settings).await?;

// 2. User visits auth_url and grants permission
// 3. Provider redirects to your callback URL with a code and state

// 4. Verify state matches to prevent CSRF
if received_state != state.secret() {
    return Err(AppError::InvalidToken("OIDC state mismatch".to_string()));
}

// 5. Exchange code for tokens
let code = AuthorizationCode::new(received_code.to_string());
let token_response = exchange_oidc_code(
    "google", 
    client, 
    code, 
    pkce_verifier,
    nonce
).await?;

// 6. ID token is already verified in exchange_oidc_code
// Extract claims from ID token
let id_token = token_response.id_token().unwrap();
let claims = id_token.claims(&client.id_token_verifier(), &nonce).unwrap();

let sub = claims.subject().to_string();
let email = claims.email()
    .ok_or_else(|| AppError::OAuthUserInfoFailed("Missing email claim".to_string()))?
    .to_string();

// 7. Optionally fetch additional user info
if let Ok(user_info) = fetch_oidc_user_info("google", &client, &token_response).await {
    // Process additional user info
}

// 8. Create or update user record
let user = user_service.find_or_create_oauth_user(
    "google",
    sub,
    email,
    claims.name().map(|n| n.to_string()),
).await?;
```

</examples>

<common_issues>

## OAuth Client Endpoint Issues
- Missing or incorrect auth/token URL endpoints
- Forgetting to set the redirect URI
- Using the wrong client type for the provider

## OIDC Provider Metadata Issues
- Incorrect discovery URL
- Network failures during discovery
- Missing required endpoints in provider metadata

## Token Verification Issues
- Not verifying the nonce in ID tokens
- Not checking signature of ID tokens
- Not verifying the access token hash
- Not checking token expiration

## OIDC Authorization URL Generation Issues
- Using the wrong `authorize_url` flow type
- Ensure you use `AuthenticationFlow::<CoreResponseType>::AuthorizationCode` for OIDC clients
- Properly configure `state` and `nonce` generators with the correct closures: `|| state.clone()`
- Use `.set_redirect_uri()` before calling `.authorize_url()`

## OIDC Token Exchange Issues
- Make sure the client is properly configured with all required endpoints
- Use the correct `exchange_code` method for your client type
- For access token hash verification, provide a proper dummy key implementation
- Use `CoreJsonWebKey::new_ec()` with appropriate parameters for the dummy key

## User Info Issues
- Not handling provider-specific user info endpoints correctly
- Missing required scopes for user info
- Not properly parsing different user info formats

## Error Handling Issues
- Not providing enough context in error messages
- Not logging sufficient information for debugging
- Exposing sensitive error details to users

</common_issues>

<dependencies>

## Required Crates
- `oauth2`: For OAuth 2.0 protocol implementation
- `openidconnect`: For OpenID Connect protocol implementation
- `reqwest`: For HTTP client functionality
- `secrecy`: For secure handling of sensitive information
- `url`: For URL parsing and manipulation
- `anyhow`: For error handling
- `tracing`: For logging and instrumentation

</dependencies>
