---
description: This rule documents the proper way to handle SQLx executor references in the PyWatt-Rust project, focusing on mutable vs. immutable references for transactions and connection pools.
globs: 
alwaysApply: false
---
# SQLx Executor References

<context>
This rule documents the proper way to handle SQLx executor references in the PyWatt-Rust project, focusing on mutable vs. immutable references for transactions and connection pools.
</context>

<rules>

## Executor References
- For transactions, always use `&mut *tx` when passing to query execution methods
- For direct pool access, use `&*self.db_pool` when borrowing from an Arc<PgPool>
- Never use `&*tx` as this will result in "trait bound `&PgConnection: sqlx::Executor<'_>` is not satisfied" errors
- The Executor trait is implemented for `&mut PgConnection` but not for `&PgConnection`

## Transaction Methods
- All query execution methods require a mutable reference when used with transactions:
  - `.execute(&mut *tx)`
  - `.fetch_one(&mut *tx)`
  - `.fetch_optional(&mut *tx)`
  - `.fetch_all(&mut *tx)`
- This applies to all query types: `query!`, `query_as!`, and `query_scalar!`

## Pool Methods
- Direct pool access uses immutable references:
  - `.execute(&*self.db_pool)`
  - `.fetch_one(&*self.db_pool)`
  - `.fetch_optional(&*self.db_pool)`
  - `.fetch_all(&*self.db_pool)`
- This is because the pool internally manages its connections

## Error Messages
- "the trait `sqlx::Executor<'_>` is not implemented for `&PgConnection`" indicates using an immutable reference with transactions
- "the trait bound `&PgConnection: sqlx::Executor<'_>` is not satisfied" means you need to use a mutable reference

</rules>

<patterns>

## Correct Transaction Usage
```rust
// Start a transaction
let mut tx = pool.begin().await?;

// Execute a query within the transaction - use &mut *tx
sqlx::query!(
    "INSERT INTO items (id, name) VALUES ($1, $2)",
    item_id,
    name
)
.execute(&mut *tx)
.await?;

// Fetch one result within the transaction - use &mut *tx
let result = sqlx::query_as!(
    Item,
    "SELECT * FROM items WHERE id = $1",
    item_id
)
.fetch_one(&mut *tx)
.await?;

// Commit the transaction
tx.commit().await?;
```

## Correct Pool Usage
```rust
// Direct pool query - use &*self.db_pool
let items = sqlx::query_as!(
    Item,
    "SELECT * FROM items ORDER BY created_at DESC LIMIT $1",
    limit
)
.fetch_all(&*self.db_pool)
.await?;

// Check if item exists - use &*self.db_pool
let item = sqlx::query_as!(
    Item,
    "SELECT * FROM items WHERE id = $1",
    item_id
)
.fetch_optional(&*self.db_pool)
.await?;
```

## Transaction with Multiple Operations
```rust
pub async fn transfer_funds(
    from_account_id: Uuid,
    to_account_id: Uuid,
    amount: Decimal,
) -> Result<(), Error> {
    // Start a transaction
    let mut tx = self.pool.begin().await?;
    
    // First query - use &mut *tx
    sqlx::query!(
        "UPDATE accounts SET balance = balance - $1 WHERE id = $2",
        amount,
        from_account_id
    )
    .execute(&mut *tx)
    .await?;
    
    // Second query - use &mut *tx
    sqlx::query!(
        "UPDATE accounts SET balance = balance + $1 WHERE id = $2",
        amount,
        to_account_id
    )
    .execute(&mut *tx)
    .await?;
    
    // Third query - use &mut *tx
    sqlx::query!(
        "INSERT INTO transactions (from_id, to_id, amount) VALUES ($1, $2, $3)",
        from_account_id,
        to_account_id,
        amount
    )
    .execute(&mut *tx)
    .await?;
    
    // Commit the transaction
    tx.commit().await?;
    
    Ok(())
}
```

</patterns>

<examples>

## Common Error Example
```rust
// ❌ INCORRECT: Using immutable reference
let result = sqlx::query_scalar!(
    "INSERT INTO items (name) VALUES ($1) RETURNING id",
    name
)
.fetch_one(&*tx)  // This will fail with "trait bound not satisfied" error
.await?;

// ✅ CORRECT: Using mutable reference
let result = sqlx::query_scalar!(
    "INSERT INTO items (name) VALUES ($1) RETURNING id",
    name
)
.fetch_one(&mut *tx)
.await?;
```

## Complex Transaction Example
```rust
pub async fn create_user_with_profile(
    &self,
    username: &str,
    email: &str,
    profile_data: ProfileData,
) -> Result<User, Error> {
    // Start transaction
    let mut tx = self.pool.begin().await?;
    
    // Create user - use mutable reference
    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (username, email)
        VALUES ($1, $2)
        RETURNING id, username, email, created_at
        "#,
        username,
        email
    )
    .fetch_one(&mut *tx)
    .await?;
    
    // Create profile - use mutable reference
    sqlx::query!(
        r#"
        INSERT INTO profiles (user_id, display_name, bio)
        VALUES ($1, $2, $3)
        "#,
        user.id,
        profile_data.display_name,
        profile_data.bio
    )
    .execute(&mut *tx)
    .await?;
    
    // Create default settings - use mutable reference
    sqlx::query!(
        r#"
        INSERT INTO user_settings (user_id, theme, notifications_enabled)
        VALUES ($1, 'default', true)
        "#,
        user.id
    )
    .execute(&mut *tx)
    .await?;
    
    // Commit all changes
    tx.commit().await?;
    
    Ok(user)
}
```

</examples>

<troubleshooting>

## Common Errors

### Immutable Transaction Reference
- Error: "the trait `sqlx::Executor<'_>` is not implemented for `&PgConnection`"
- Solution: Change `&*tx` to `&mut *tx` in all query execution calls

### Mixing Pool and Transaction References
- Error: Type mismatch errors when passing a transaction to a function expecting a pool
- Solution: Ensure functions accept the appropriate executor type (either transactions or pools)

### Multiple Mutable Borrows of Transaction
- Error: "cannot borrow `*tx` as mutable more than once at a time"
- Solution: Complete one query before starting another, or use separate blocks to limit borrow scope

## Best Practices
- Always use `&mut *tx` for transaction operations
- Always use `&*self.db_pool` for direct pool operations
- Consider creating helper methods that take the correct executor type
- Add explicit type annotations to clarify expected executor types

</troubleshooting>
