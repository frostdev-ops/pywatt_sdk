---
description: This rule documents proper lifetime handling for Axum extractors in the PyWatt-Rust project, with a focus on the correct implementation of the FromRequestParts trait.
globs: 
alwaysApply: false
---
# Axum Extractor Lifetimes

<context>
This rule documents proper lifetime handling for Axum extractors in the PyWatt-Rust project, with a focus on the correct implementation of the FromRequestParts trait.
</context>

<rules>

## FromRequestParts Implementation
- When implementing `FromRequestParts`, use the exact lifetime parameters as defined in the trait
- The lifetime parameters are: `<'a, 's>`
- The `parts` parameter has lifetime `&'a mut Parts`
- The `state` parameter has lifetime `&'s S`
- Do not change or omit these lifetime parameters in your implementation

## Async Trait Attributes
- Always use the `#[async_trait]` attribute from the async-trait crate
- Place it directly above the impl block, not on individual methods

## State Type Parameters
- Use generic state parameter `S` with appropriate bounds
- Common bounds include `S: Send + Sync` or `S: AsRef<AppState> + Send + Sync`
- Do not use concrete state types like `AppState` directly unless necessary

## Rejection Type
- Define a descriptive rejection type that clearly indicates what went wrong
- Typically use `type Rejection = AppError;` for consistency
- Ensure the rejection can be converted to an HTTP response via `IntoResponse`

</rules>

<patterns>

## Basic FromRequestParts Implementation
```rust
#[async_trait]
impl<S> FromRequestParts<S> for MyExtractor
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts,
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Implementation goes here
        // ...
        Ok(MyExtractor { /* ... */ })
    }
}
```

## State Access Implementation
```rust
#[async_trait]
impl<S> FromRequestParts<S> for MyExtractor
where
    S: AsRef<AppState> + Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts,
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Access AppState through AsRef trait
        let app_state = state.as_ref();
        
        // Access services from the state
        let some_service = &app_state.some_service;
        
        // Implementation using services
        // ...
        
        Ok(MyExtractor { /* ... */ })
    }
}
```

## Extractor That Depends On Another Extractor
```rust
#[async_trait]
impl<S> FromRequestParts<S> for RequiresAuth
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts,
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Extract auth first
        let auth = AuthenticatedUser::from_request_parts(parts, state).await?;
        
        // Use the extracted auth data
        // ...
        
        Ok(RequiresAuth { user_id: auth.user_id })
    }
}
```

## Extractor With Optional Dependencies
```rust
#[async_trait]
impl<S> FromRequestParts<S> for OptionalAuth
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts,
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Try to extract auth but don't fail if not present
        let auth = match AuthenticatedUser::from_request_parts(parts, state).await {
            Ok(auth) => Some(auth),
            Err(_) => None,
        };
        
        Ok(OptionalAuth { user: auth })
    }
}
```

</patterns>

<examples>

## API Key Authentication Extractor
```rust
// API Key authentication extractor
pub struct ApiKeyAuth {
    pub user_id: uuid::Uuid,
    pub key_id: uuid::Uuid,
}

#[async_trait]
impl<S> FromRequestParts<S> for ApiKeyAuth
where
    S: AsRef<AppState> + Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts, 
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Access API key service from the state
        let api_key_service = &state.as_ref().api_key_service;

        // Extract Authorization header
        let auth_header = parts
            .headers
            .get(http::header::AUTHORIZATION)
            .and_then(|value| value.to_str().ok());

        let token = match auth_header {
            Some(header) if header.starts_with("Bearer ") => {
                header.trim_start_matches("Bearer ").to_string()
            }
            _ => {
                return Err(AppError::InvalidToken(
                    "Missing or invalid API key".to_string(),
                ));
            }
        };

        // Verify the key using the service
        let (user_id, key_id) = api_key_service.verify_api_key(&token).await?;
        
        Ok(ApiKeyAuth { user_id, key_id })
    }
}
```

## Required Permission Extractor
```rust
// Permission requirement extractor
pub struct RequirePermission {
    pub user_id: uuid::Uuid,
    pub permission_code: String,
}

#[async_trait]
impl<S> FromRequestParts<S> for RequirePermission
where
    S: AsRef<AppState> + Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts, 
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Extract the authenticated user first
        let auth_user = AuthenticatedUser::from_request_parts(parts, state).await?;
        
        // Get the required permission from path or query parameters
        let uri = &parts.uri;
        let query_params: Query<HashMap<String, String>> = 
            Query::try_from_uri(uri)
            .map_err(|_| AppError::BadRequest("Invalid query parameters".to_string()))?;
            
        let permission_code = query_params.0.get("permission")
            .ok_or_else(|| AppError::BadRequest("Missing required permission parameter".to_string()))?
            .clone();
            
        // Access permission service and check user's permission
        let permission_service = &state.as_ref().permission_service;
        let has_permission = permission_service
            .user_has_permission(auth_user.user_id, &permission_code)
            .await?;
            
        if !has_permission {
            return Err(AppError::Forbidden(
                format!("User lacks required permission: {}", permission_code)
            ));
        }
        
        Ok(RequirePermission { 
            user_id: auth_user.user_id,
            permission_code,
        })
    }
}
```

## Parsing Custom Header Extractor
```rust
// Custom header extractor
pub struct ApiVersion(pub String);

#[async_trait]
impl<S> FromRequestParts<S> for ApiVersion
where
    S: Send + Sync,
{
    type Rejection = AppError;

    async fn from_request_parts<'a, 's>(
        parts: &'a mut Parts, 
        state: &'s S,
    ) -> Result<Self, Self::Rejection> {
        // Look for X-API-Version header
        let version = parts.headers
            .get("X-API-Version")
            .and_then(|v| v.to_str().ok())
            .map(|v| v.to_string())
            .unwrap_or_else(|| "1.0".to_string()); // Default to 1.0
            
        Ok(ApiVersion(version))
    }
}
```

</examples>

<troubleshooting>

## Common Errors

### Lifetime Parameter Errors
- "lifetime parameters or bounds on associated function `from_request_parts` do not match the trait declaration"
  - Cause: Using incorrect lifetime parameters in implementation
  - Solution: Use exactly `<'a, 's>` as defined in the trait

- "type reference is not valid for the associated type"
  - Cause: Lifetime parameters in the return type don't match implementation
  - Solution: Ensure the returned type's lifetimes are compatible

### Trait Bounds Errors
- "the trait bound `S: AsRef<AppState>` is not satisfied"
  - Cause: Using a service from state without proper bounds
  - Solution: Add `AsRef<AppState>` to the bounds on S

- "the trait `FromRequestParts<AppState>` is not implemented for `MyExtractor`"
  - Cause: Implementing for a concrete state type instead of a generic one
  - Solution: Change the implementation to use a generic state parameter

### Header Extraction Errors
- "called `Option::unwrap()` on a `None` value"
  - Cause: Trying to unwrap a header that doesn't exist
  - Solution: Use `and_then`, `map_or_else`, or handle the `None` case explicitly

## Debugging Tips
- Add tracing to extractor implementations to debug extraction failures
- Use proper error types that provide clear information about what went wrong
- Test extractors in isolation before using them in route handlers
- Ensure all required headers or parameters are present in test requests

</troubleshooting>
