---
description: This rule documents how to properly handle Decimal values in SQLX queries within the PyWatt-Rust project, including common issues and best practices for working with Rust's Decimal type in database operations.
globs: 
alwaysApply: false
---
# SQLX Decimal Handling

<context>
This rule documents how to properly handle Decimal values in SQLX queries within the PyWatt-Rust project, including common issues and best practices for working with Rust's Decimal type in database operations.
</context>

<rules>

## Query Return Types
- Always ensure that query_as! macros expecting Decimal fields have proper type annotations.
- For queries that return Decimal values, use explicit type casting in SQL or proper Rust type conversions.
- When updating tables with Decimal columns, ensure the return values are properly typed.
- Never use empty parenthesis `()` where a Decimal is expected.

## Type Conversions
- Use proper type conversions between SQL numeric types and Rust's Decimal type.
- Be aware that SQLX cannot automatically convert unit value `()` to Decimal.
- Always provide explicit types for query parameters involving Decimal values.
- For optional Decimal values, handle null cases explicitly in SQL or Rust.

## Error Handling
- Handle type conversion errors explicitly, especially when working with financial data.
- Validate Decimal values before using them in queries to ensure they meet business requirements.
- Log detailed error information for debugging financial calculation issues.
- Use proper error types for different kinds of Decimal-related errors.

## Testing
- Write comprehensive tests for all code handling Decimal values, especially financial calculations.
- Include edge cases in tests, such as zero amounts, negative amounts, and very large/small amounts.
- Test with a variety of currency values and decimal precisions.
- Verify rounding behavior matches business requirements.

</rules>

<patterns>

## Proper SQLX Query for Decimal Return
```rust
// Use explicit SQL type casting for Decimal return values
let invoice = sqlx::query_as!(
    Invoice,
    r#"
    SELECT 
        id, customer_id, subscription_id, number, amount::numeric,
        currency, status, description, due_date, paid_at, created_at, updated_at
    FROM invoices
    WHERE id = $1
    "#,
    invoice_id
)
.fetch_one(&self.db_pool)
.await?;
```

## Handling Optional Decimal Values
```rust
// Use COALESCE for optional Decimal parameters
let updated_invoice = sqlx::query_as!(
    Invoice,
    r#"
    UPDATE invoices
    SET 
        amount = COALESCE($2, amount),
        currency = COALESCE($3, currency),
        status = COALESCE($4, status)
    WHERE id = $1
    RETURNING 
        id, customer_id, subscription_id, number, amount::numeric,
        currency, status, description, due_date, paid_at, created_at, updated_at
    "#,
    invoice_id,
    amount,
    currency,
    status_str,
)
.fetch_one(&self.db_pool)
.await?;
```

## Converting Between Decimal and SQL Types
```rust
// Convert Rust Decimal to SQL numeric
pub fn decimal_to_sql(value: Decimal) -> sqlx::types::Decimal {
    sqlx::types::Decimal::from_str(&value.to_string())
        .expect("Failed to convert decimal")
}

// Convert SQL numeric to Rust Decimal
pub fn sql_to_decimal(value: sqlx::types::Decimal) -> Decimal {
    Decimal::from_str(&value.to_string())
        .expect("Failed to convert SQL decimal")
}
```

## Handling Query with Decimal Sum
```rust
// Use explicit casting for aggregate functions
let result = sqlx::query!(
    r#"
    SELECT 
        SUM(amount)::numeric as total_amount
    FROM invoices
    WHERE customer_id = $1 AND status = 'paid'
    "#,
    customer_id
)
.fetch_one(&self.db_pool)
.await?;

let total: Decimal = if let Some(amount) = result.total_amount {
    amount
} else {
    Decimal::ZERO
};
```

## Ensuring Decimal Values in Struct
```rust
#[derive(Debug, sqlx::FromRow)]
pub struct Invoice {
    pub id: Uuid,
    pub customer_id: Uuid,
    pub subscription_id: Option<Uuid>,
    pub number: String,
    pub amount: Decimal,  // Using rust_decimal::Decimal
    pub currency: String,
    pub status: String,
    pub description: Option<String>,
    pub due_date: Option<NaiveDate>,
    pub paid_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}
```

</patterns>

<examples>

## Complete Invoice Creation Example
```rust
pub async fn create_invoice(
    &self,
    customer_id: Uuid,
    amount: Decimal,
    currency: String,
    description: Option<String>,
    due_days: Option<i32>,
) -> AppResult<Invoice> {
    // Generate invoice number
    let next_number = self.get_next_invoice_number().await?;
    let invoice_number = format!("INV-{:08}", next_number);
    
    // Calculate due date
    let due_date = if let Some(days) = due_days {
        Some(Utc::now().naive_utc().date() + Duration::days(days as i64))
    } else {
        None
    };
    
    // Create the invoice
    let invoice = sqlx::query_as!(
        Invoice,
        r#"
        INSERT INTO invoices (
            customer_id, number, amount, currency, 
            status, description, due_date
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING 
            id, customer_id, subscription_id, number, amount::numeric,
            currency, status, description, due_date, paid_at, created_at, updated_at
        "#,
        customer_id,
        invoice_number,
        amount,  // Pass Decimal directly
        currency,
        "draft",  // Initial status
        description,
        due_date,
    )
    .fetch_one(&self.db_pool)
    .await?;
    
    Ok(invoice)
}
```

## Handling Decimal in Payment Processing
```rust
pub async fn process_payment(
    &self,
    payment_id: Uuid,
    success: bool,
    error_message: Option<String>,
) -> AppResult<Payment> {
    // Start transaction
    let mut tx = self.db_pool.begin().await?;
    
    // Update payment
    let status = if success { "succeeded" } else { "failed" };
    
    // Note the ::numeric casting for Decimal return values
    let payment = sqlx::query_as!(
        Payment,
        r#"
        UPDATE payments
        SET 
            status = $2,
            error_message = $3,
            processed_at = $4
        WHERE id = $1
        RETURNING 
            id, invoice_id, amount::numeric, method, provider, 
            transaction_id, status, error_message, 
            metadata, created_at, processed_at
        "#,
        payment_id,
        status,
        error_message,
        Utc::now(),
    )
    .fetch_one(&mut *tx)
    .await?;
    
    // If payment succeeded, update the invoice too
    if success {
        sqlx::query!(
            r#"
            UPDATE invoices
            SET 
                status = 'paid',
                paid_at = $2
            WHERE id = $1
            "#,
            payment.invoice_id,
            Utc::now(),
        )
        .execute(&mut *tx)
        .await?;
    }
    
    // Commit transaction
    tx.commit().await?;
    
    Ok(payment)
}
```

## Calculating Totals with Decimal
```rust
pub async fn get_customer_balance(
    &self,
    customer_id: Uuid,
) -> AppResult<Decimal> {
    // Get sum of unpaid invoices
    let result = sqlx::query!(
        r#"
        SELECT 
            COALESCE(SUM(amount), 0)::numeric as total_due
        FROM invoices
        WHERE 
            customer_id = $1 AND 
            status IN ('draft', 'open') AND
            (due_date IS NULL OR due_date >= CURRENT_DATE)
        "#,
        customer_id
    )
    .fetch_one(&self.db_pool)
    .await?;
    
    // Safely convert to Decimal with fallback to zero
    let total_due = result.total_due.unwrap_or(Decimal::ZERO);
    
    Ok(total_due)
}
```

</examples>

<common_issues>

## Missing Numeric Type Casting
```rust
// Incorrect: Missing ::numeric cast
let invoice = sqlx::query_as!(
    Invoice,
    r#"
    SELECT 
        id, customer_id, subscription_id, number, amount, 
        currency, status, description, due_date, paid_at, created_at, updated_at
    FROM invoices
    WHERE id = $1
    "#,
    invoice_id
)
.fetch_one(&self.db_pool)
.await?;

// Correct: With ::numeric cast
let invoice = sqlx::query_as!(
    Invoice,
    r#"
    SELECT 
        id, customer_id, subscription_id, number, amount::numeric, 
        currency, status, description, due_date, paid_at, created_at, updated_at
    FROM invoices
    WHERE id = $1
    "#,
    invoice_id
)
.fetch_one(&self.db_pool)
.await?;
```

## Type Mismatch in Updates
```rust
// Incorrect: Missing proper return values
let invoice = sqlx::query_as!(
    Invoice,
    r#"
    UPDATE invoices
    SET status = 'paid', paid_at = $2
    WHERE id = $1
    "#,
    invoice_id,
    Utc::now(),
)
.fetch_one(&self.db_pool)
.await?;

// Correct: With RETURNING clause and proper type casting
let invoice = sqlx::query_as!(
    Invoice,
    r#"
    UPDATE invoices
    SET status = 'paid', paid_at = $2
    WHERE id = $1
    RETURNING 
        id, customer_id, subscription_id, number, amount::numeric, 
        currency, status, description, due_date, paid_at, created_at, updated_at
    "#,
    invoice_id,
    Utc::now(),
)
.fetch_one(&self.db_pool)
.await?;
```

## Incorrect Transaction Usage
```rust
// Incorrect: Using reference instead of mutable reference
sqlx::query!(...)
.execute(&tx)
.await?;

// Correct: Using mutable reference
sqlx::query!(...)
.execute(&mut *tx)
.await?;
```

## Incorrect Optional Decimal Handling
```rust
// Incorrect: Missing fallback for NULL values
let result = sqlx::query!(
    "SELECT SUM(amount) as total FROM invoices WHERE customer_id = $1",
    customer_id
)
.fetch_one(&self.db_pool)
.await?;

let total = result.total; // This might be NULL, causing a conversion error

// Correct: Using COALESCE in SQL
let result = sqlx::query!(
    "SELECT COALESCE(SUM(amount), 0)::numeric as total FROM invoices WHERE customer_id = $1",
    customer_id
)
.fetch_one(&self.db_pool)
.await?;

let total = result.total; // This will never be NULL
```

</common_issues>

<dependencies>

## Required Crates
- `rust_decimal`: For high-precision decimal arithmetic
- `sqlx`: For database interactions with type safety
- `chrono`: For date and time handling
- `uuid`: For unique identifiers
- `serde`: For serialization/deserialization

</dependencies>
