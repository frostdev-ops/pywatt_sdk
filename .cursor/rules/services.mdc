---
description: The service layer implements the core business logic of the application, encapsulating domain rules, data access, and external integrations. It provides a clean separation between the API layer and the underlying implementation details.
globs: 
alwaysApply: false
---
# Service Layer

## Purpose
The service layer implements the core business logic of the application, encapsulating domain rules, data access, and external integrations. It provides a clean separation between the API layer and the underlying implementation details.

## Key Types & Structures
```rust
// Core Services
pub struct AuthService {
    db: PgPool,
    settings: Arc<Settings>,
    permission_service: Arc<PermissionService>,
    email_service: Arc<dyn EmailService>,
    redis_client: RedisClient,
}

pub struct UserService {
    db: PgPool,
    permission_service: Arc<PermissionService>,
}

// Business Services
pub struct CustomerService {
    db: PgPool,
}

pub struct ProductService {
    db: PgPool,
}

pub struct InvoiceService {
    db: PgPool,
    customer_service: Arc<CustomerService>,
    product_service: Arc<ProductService>,
}

// AI & Chat Services
pub struct LlmService {
    settings: Arc<Settings>,
}

pub struct ChatOrchestrationService {
    llm_service: Arc<LlmService>,
    memory_service: Arc<MemoryService>,
    mcp_registry: Arc<McpRegistryService>,
    db: PgPool,
    settings: Arc<Settings>,
}
```

## Service Categories
### Authentication & Authorization
```rust
impl AuthService {
    pub async fn login(
        &self,
        credentials: LoginCredentials,
    ) -> AppResult<AuthResponse> {
        let user = self.validate_credentials(credentials).await?;
        let tokens = self.generate_tokens(&user).await?;
        Ok(AuthResponse { user, tokens })
    }
    
    pub async fn refresh_token(
        &self,
        refresh_token: &str,
    ) -> AppResult<TokenPair> {
        let claims = self.validate_refresh_token(refresh_token)?;
        self.generate_token_pair(&claims.sub).await
    }
}

impl PermissionService {
    pub async fn check_permission(
        &self,
        user_id: Uuid,
        permission: &str,
    ) -> AppResult<bool> {
        let roles = self.get_user_roles(user_id).await?;
        Ok(self.has_permission(&roles, permission))
    }
}
```

### User Management
```rust
impl UserService {
    pub async fn create_user(
        &self,
        new_user: NewUser,
    ) -> AppResult<User> {
        self.validate_user_data(&new_user)?;
        let user = self.db.create_user(new_user).await?;
        Ok(user)
    }
    
    pub async fn update_user(
        &self,
        user_id: Uuid,
        update: UserUpdate,
    ) -> AppResult<User> {
        self.validate_update(&update)?;
        let user = self.db.update_user(user_id, update).await?;
        Ok(user)
    }
}
```

### Business Logic
```rust
impl InvoiceService {
    pub async fn create_invoice(
        &self,
        new_invoice: NewInvoice,
    ) -> AppResult<Invoice> {
        let customer = self.customer_service
            .get_customer(new_invoice.customer_id)
            .await?;
            
        let products = self.product_service
            .get_products(&new_invoice.product_ids)
            .await?;
            
        let invoice = self.calculate_invoice(customer, products)?;
        self.db.create_invoice(invoice).await
    }
}

impl PaymentService {
    pub async fn process_payment(
        &self,
        payment: Payment,
    ) -> AppResult<PaymentResult> {
        let intent = self.create_payment_intent(payment).await?;
        self.confirm_payment(intent.id).await
    }
}
```

### AI & Chat
```rust
impl ChatOrchestrationService {
    pub async fn process_message(
        &self,
        conversation_id: Uuid,
        message: ChatMessage,
    ) -> AppResult<ChatResponse> {
        let context = self.memory_service
            .get_relevant_context(conversation_id, &message.content)
            .await?;
            
        let response = self.llm_service
            .generate_response(message, context)
            .await?;
            
        self.memory_service
            .store_interaction(conversation_id, &message, &response)
            .await?;
            
        Ok(response)
    }
}
```

## Design Patterns
### Repository Pattern
- **Purpose**: Abstracts data access
- **Implementation**: Database operations in services
- **Usage**: CRUD operations through services

### Dependency Injection
- **Purpose**: Manages service dependencies
- **Implementation**: Constructor-based injection
- **Usage**: Services receive dependencies at creation

### Service Composition
- **Purpose**: Builds complex operations
- **Implementation**: Services use other services
- **Usage**: Higher-level services compose lower-level ones

## Error Handling
```rust
impl AuthService {
    async fn validate_credentials(
        &self,
        credentials: LoginCredentials,
    ) -> AppResult<User> {
        let user = self.db
            .get_user_by_email(&credentials.email)
            .await
            .map_err(|_| AppError::InvalidCredentials)?;
            
        if !self.verify_password(&credentials.password, &user.password_hash)? {
            return Err(AppError::InvalidCredentials);
        }
        
        Ok(user)
    }
}
```

## Testing Approach
### Unit Tests
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_create_user() {
        let db = setup_test_db().await;
        let permission_service = Arc::new(PermissionService::new(db.clone()));
        let service = UserService::new(db, permission_service);
        
        let result = service
            .create_user(NewUser {
                email: "test@example.com".into(),
                password: "password123".into(),
            })
            .await;
            
        assert!(result.is_ok());
    }
}
```

### Integration Tests
- Test service interactions
- Database operations
- External service mocking
- Error scenarios

## Dependencies
### Internal Dependencies
- `models/*`: Data structures
- `errors.rs`: Error types
- `utils/*`: Helper functions
- Other services

### External Dependencies
- `sqlx`: Database access
- `redis`: Caching
- `reqwest`: HTTP client
- `tokio`: Async runtime

## Notes & Best Practices
### Performance Considerations
- Connection pooling
- Caching strategies
- Batch operations
- Async operations

### Security Considerations
- Input validation
- Password hashing
- Token management
- Rate limiting

### Rust Idioms
- Error propagation
- Async/await usage
- Type safety
- Resource management

### Maintenance Notes
- Document dependencies
- Monitor performance
- Handle upgrades
- Test coverage

## Related Components
- `models/*`: Data structures
- `routes/*`: API endpoints
- `middleware/*`: Request processing
- `utils/*`: Helper functions
