---
description: This rule documents common patterns and best practices for implementing services in the PyWatt-Rust project, focusing on state management, database access, and error handling.
globs: 
alwaysApply: false
---
# Service Implementation Patterns

<context>
This rule documents common patterns and best practices for implementing services in the PyWatt-Rust project, focusing on state management, database access, and error handling.
</context>

<rules>

## Service Structure
- Services should be implemented as structs with fields for dependencies
- Use `Arc<T>` for shared resources like database pools
- Avoid using `Clone` on services that hold database connections or other heavy resources
- Implement a `new` method that takes all required dependencies
- Use constructor functions that validate inputs and return `AppResult<Service>`

## Database Access
- Access the database through an `Arc<PgPool>` field
- For read operations directly on the pool, use `&*self.db_pool`
- For write operations that need a mutable executor, use `&mut *self.db_pool`
- For transactions, always use `&mut *tx` when executing queries

## Error Handling
- Service methods should return `AppResult<T>` for consistent error handling
- Use the `?` operator to propagate errors from database operations
- Map database errors to domain-specific errors when appropriate
- Document possible error cases in method documentation

## State Management
- Services should be stateless whenever possible
- Store state in the database or external cache (Redis) rather than in memory
- If in-memory state is required, use proper synchronization primitives
- Consider using a background task for periodic state updates

## Method Documentation
- Document the purpose of each public method
- Indicate what errors can be returned
- Use the `#[instrument]` attribute for logging and tracing
- Skip sensitive parameters with `#[instrument(skip(param))]`

</rules>

<patterns>

## Basic Service Implementation
```rust
/// Service for managing users
pub struct UserService {
    db_pool: Arc<PgPool>,
    config: UserServiceConfig,
}

impl UserService {
    /// Create a new user service
    pub fn new(db_pool: Arc<PgPool>, config: UserServiceConfig) -> Self {
        Self { db_pool, config }
    }

    /// Get a user by ID
    #[instrument(skip(self), err)]
    pub async fn get_user(&self, user_id: Uuid) -> AppResult<User> {
        let user = sqlx::query_as!(
            User,
            r#"SELECT * FROM users WHERE id = $1"#,
            user_id
        )
        .fetch_optional(&*self.db_pool)
        .await?
        .ok_or_else(|| AppError::NotFound(format!("User not found: {}", user_id)))?;

        Ok(user)
    }

    /// Create a new user
    #[instrument(skip(self, password), err, fields(email = %user.email))]
    pub async fn create_user(&self, user: CreateUserDto, password: &str) -> AppResult<User> {
        // Check if email is already taken
        let existing = sqlx::query!(
            r#"SELECT id FROM users WHERE email = $1"#,
            user.email
        )
        .fetch_optional(&*self.db_pool)
        .await?;

        if existing.is_some() {
            return Err(AppError::Conflict("Email already in use".to_string()));
        }

        // Hash password
        let password_hash = hash_password(password)?;

        // Start a transaction
        let mut tx = self.db_pool.begin().await?;

        // Insert the user
        let created_user = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (name, email, password_hash)
            VALUES ($1, $2, $3)
            RETURNING id, name, email, created_at, updated_at
            "#,
            user.name,
            user.email,
            password_hash
        )
        .fetch_one(&mut *tx)
        .await?;

        // Commit the transaction
        tx.commit().await?;

        Ok(created_user)
    }
}
```

## Service with Multiple Dependencies
```rust
/// Service for managing subscriptions
pub struct SubscriptionService {
    db_pool: Arc<PgPool>,
    user_service: Arc<UserService>,
    payment_service: Arc<PaymentService>,
    notification_service: Arc<NotificationService>,
}

impl SubscriptionService {
    /// Create a new subscription service
    pub fn new(
        db_pool: Arc<PgPool>,
        user_service: Arc<UserService>,
        payment_service: Arc<PaymentService>,
        notification_service: Arc<NotificationService>,
    ) -> Self {
        Self {
            db_pool,
            user_service,
            payment_service,
            notification_service,
        }
    }

    /// Create a subscription for a user
    #[instrument(skip(self), err)]
    pub async fn create_subscription(
        &self,
        user_id: Uuid,
        plan_id: Uuid,
    ) -> AppResult<Subscription> {
        // Verify user exists
        let user = self.user_service.get_user(user_id).await?;

        // Verify plan exists
        let plan = self.get_plan(plan_id).await?;

        // Start a transaction
        let mut tx = self.db_pool.begin().await?;

        // Create subscription
        let subscription = sqlx::query_as!(
            Subscription,
            r#"
            INSERT INTO subscriptions (user_id, plan_id, status)
            VALUES ($1, $2, 'active')
            RETURNING id, user_id, plan_id, status, created_at, updated_at
            "#,
            user.id,
            plan.id
        )
        .fetch_one(&mut *tx)
        .await?;

        // Process initial payment
        let payment = self.payment_service
            .create_payment(subscription.id, plan.price)
            .await?;

        // Commit transaction
        tx.commit().await?;

        // Send notification asynchronously
        let notification_service = self.notification_service.clone();
        let sub_id = subscription.id;
        tokio::spawn(async move {
            if let Err(e) = notification_service.send_subscription_notification(sub_id).await {
                tracing::error!("Failed to send subscription notification: {}", e);
            }
        });

        Ok(subscription)
    }
}
```

## Transactions with Error Handling
```rust
/// Update multiple related entities atomically
#[instrument(skip(self), err)]
pub async fn update_order(&self, order_id: Uuid, data: UpdateOrderDto) -> AppResult<Order> {
    // Start a transaction
    let mut tx = self.db_pool.begin().await?;

    // Get the current order
    let order = sqlx::query_as!(
        Order,
        r#"SELECT * FROM orders WHERE id = $1 FOR UPDATE"#,
        order_id
    )
    .fetch_optional(&mut *tx)
    .await?
    .ok_or_else(|| AppError::NotFound(format!("Order not found: {}", order_id)))?;

    // Check if order can be updated
    if order.status == OrderStatus::Completed {
        tx.rollback().await?;
        return Err(AppError::InvalidOperation(
            "Cannot update a completed order".to_string(),
        ));
    }

    // Update the order
    let updated_order = sqlx::query_as!(
        Order,
        r#"
        UPDATE orders
        SET status = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING *
        "#,
        data.status as OrderStatus,
        order_id
    )
    .fetch_one(&mut *tx)
    .await?;

    // Update order items if provided
    if let Some(items) = data.items {
        // Delete existing items
        sqlx::query!(
            r#"DELETE FROM order_items WHERE order_id = $1"#,
            order_id
        )
        .execute(&mut *tx)
        .await?;

        // Add new items
        for item in items {
            sqlx::query!(
                r#"
                INSERT INTO order_items (order_id, product_id, quantity, price)
                VALUES ($1, $2, $3, $4)
                "#,
                order_id,
                item.product_id,
                item.quantity,
                item.price
            )
            .execute(&mut *tx)
            .await?;
        }
    }

    // Commit the transaction
    tx.commit().await?;

    Ok(updated_order)
}
```

</patterns>

<examples>

## Complete CRUD Service Example
```rust
/// Service for managing projects
pub struct ProjectService {
    db_pool: Arc<PgPool>,
    permission_service: Arc<PermissionService>,
}

impl ProjectService {
    /// Create a new project service
    pub fn new(
        db_pool: Arc<PgPool>,
        permission_service: Arc<PermissionService>,
    ) -> Self {
        Self {
            db_pool,
            permission_service,
        }
    }

    /// Get a project by ID
    #[instrument(skip(self), err)]
    pub async fn get_project(&self, project_id: Uuid) -> AppResult<Project> {
        let project = sqlx::query_as!(
            Project,
            r#"SELECT * FROM projects WHERE id = $1"#,
            project_id
        )
        .fetch_optional(&*self.db_pool)
        .await?
        .ok_or_else(|| AppError::NotFound(format!("Project not found: {}", project_id)))?;

        Ok(project)
    }

    /// List projects with pagination
    #[instrument(skip(self), err)]
    pub async fn list_projects(
        &self,
        page: i64,
        page_size: i64,
        user_id: Option<Uuid>,
    ) -> AppResult<Vec<Project>> {
        // Base query
        let mut query = "SELECT * FROM projects".to_string();

        // Add filters if user_id provided
        if let Some(uid) = user_id {
            query.push_str(" WHERE owner_id = $1");
        }

        // Add pagination
        query.push_str(" ORDER BY created_at DESC LIMIT $2 OFFSET $3");

        // Execute the query
        let projects = if let Some(uid) = user_id {
            sqlx::query_as::<_, Project>(&query)
                .bind(uid)
                .bind(page_size)
                .bind((page - 1) * page_size)
                .fetch_all(&*self.db_pool)
                .await?
        } else {
            sqlx::query_as::<_, Project>(&query)
                .bind(page_size)
                .bind((page - 1) * page_size)
                .fetch_all(&*self.db_pool)
                .await?
        };

        Ok(projects)
    }

    /// Create a new project
    #[instrument(skip(self), err)]
    pub async fn create_project(
        &self,
        data: CreateProjectDto,
        owner_id: Uuid,
    ) -> AppResult<Project> {
        let mut tx = self.db_pool.begin().await?;

        // Create the project
        let project = sqlx::query_as!(
            Project,
            r#"
            INSERT INTO projects (name, description, owner_id)
            VALUES ($1, $2, $3)
            RETURNING *
            "#,
            data.name,
            data.description,
            owner_id
        )
        .fetch_one(&mut *tx)
        .await?;

        // Set up default permissions
        self.permission_service
            .create_project_permissions(project.id, owner_id, &mut tx)
            .await?;

        tx.commit().await?;

        Ok(project)
    }

    /// Update a project
    #[instrument(skip(self), err)]
    pub async fn update_project(
        &self,
        project_id: Uuid,
        data: UpdateProjectDto,
        user_id: Uuid,
    ) -> AppResult<Project> {
        // Verify permissions
        let can_edit = self.permission_service
            .user_can_edit_project(user_id, project_id)
            .await?;

        if !can_edit {
            return Err(AppError::Forbidden(
                "You don't have permission to edit this project".to_string(),
            ));
        }

        // Update the project
        let project = sqlx::query_as!(
            Project,
            r#"
            UPDATE projects
            SET name = COALESCE($1, name),
                description = COALESCE($2, description),
                updated_at = NOW()
            WHERE id = $3
            RETURNING *
            "#,
            data.name,
            data.description,
            project_id
        )
        .fetch_optional(&mut *self.db_pool)
        .await?
        .ok_or_else(|| AppError::NotFound(format!("Project not found: {}", project_id)))?;

        Ok(project)
    }

    /// Delete a project
    #[instrument(skip(self), err)]
    pub async fn delete_project(
        &self,
        project_id: Uuid,
        user_id: Uuid,
    ) -> AppResult<()> {
        // Verify permissions
        let can_delete = self.permission_service
            .user_can_delete_project(user_id, project_id)
            .await?;

        if !can_delete {
            return Err(AppError::Forbidden(
                "You don't have permission to delete this project".to_string(),
            ));
        }

        // Start a transaction
        let mut tx = self.db_pool.begin().await?;

        // Delete project permissions
        sqlx::query!(
            r#"DELETE FROM project_permissions WHERE project_id = $1"#,
            project_id
        )
        .execute(&mut *tx)
        .await?;

        // Delete project tasks
        sqlx::query!(
            r#"DELETE FROM tasks WHERE project_id = $1"#,
            project_id
        )
        .execute(&mut *tx)
        .await?;

        // Delete the project
        let result = sqlx::query!(
            r#"DELETE FROM projects WHERE id = $1"#,
            project_id
        )
        .execute(&mut *tx)
        .await?;

        if result.rows_affected() == 0 {
            tx.rollback().await?;
            return Err(AppError::NotFound(format!("Project not found: {}", project_id)));
        }

        // Commit the transaction
        tx.commit().await?;

        Ok(())
    }
}
```

## Service With Background Processing
```rust
/// Service for processing background tasks
pub struct BackgroundTaskService {
    db_pool: Arc<PgPool>,
    shutdown_tx: Mutex<Option<mpsc::Sender<()>>>,
}

impl BackgroundTaskService {
    /// Create a new background task service
    pub fn new(db_pool: Arc<PgPool>) -> Self {
        Self {
            db_pool,
            shutdown_tx: Mutex::new(None),
        }
    }

    /// Start the background processing
    pub async fn start(&self) -> AppResult<()> {
        // Create a channel for shutdown signaling
        let (tx, mut rx) = mpsc::channel::<()>(1);
        
        // Store the sender for later shutdown
        let mut shutdown_tx = self.shutdown_tx.lock().await;
        *shutdown_tx = Some(tx);
        
        // Clone resources needed by the background task
        let db_pool = self.db_pool.clone();
        
        // Spawn the background task
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));
            
            loop {
                tokio::select! {
                    _ = interval.tick() => {
                        if let Err(e) = process_pending_tasks(&db_pool).await {
                            tracing::error!("Error processing pending tasks: {}", e);
                        }
                    }
                    _ = rx.recv() => {
                        tracing::info!("Shutting down background task processor");
                        break;
                    }
                }
            }
        });
        
        tracing::info!("Background task processor started");
        Ok(())
    }

    /// Stop the background processing
    pub async fn stop(&self) -> AppResult<()> {
        let mut shutdown_tx = self.shutdown_tx.lock().await;
        
        if let Some(tx) = shutdown_tx.take() {
            if tx.send(()).await.is_err() {
                tracing::warn!("Background task processor was already stopped");
            } else {
                tracing::info!("Background task processor stopping");
            }
        }
        
        Ok(())
    }
}

/// Process pending tasks
async fn process_pending_tasks(db_pool: &PgPool) -> AppResult<()> {
    // Get pending tasks
    let tasks = sqlx::query_as!(
        PendingTask,
        r#"
        SELECT * FROM pending_tasks
        WHERE status = 'pending'
        AND scheduled_at <= NOW()
        LIMIT 50
        "#
    )
    .fetch_all(&*db_pool)
    .await?;
    
    // Process each task
    for task in tasks {
        // Mark as processing
        sqlx::query!(
            r#"
            UPDATE pending_tasks
            SET status = 'processing', started_at = NOW()
            WHERE id = $1
            "#,
            task.id
        )
        .execute(&mut *db_pool)
        .await?;
        
        // Process the task based on its type
        let result = match task.task_type.as_str() {
            "email" => process_email_task(&task, db_pool).await,
            "report" => process_report_task(&task, db_pool).await,
            _ => {
                tracing::warn!("Unknown task type: {}", task.task_type);
                Err(AppError::InvalidOperation(format!("Unknown task type: {}", task.task_type)))
            }
        };
        
        // Update task status based on result
        match result {
            Ok(_) => {
                sqlx::query!(
                    r#"
                    UPDATE pending_tasks
                    SET status = 'completed', completed_at = NOW()
                    WHERE id = $1
                    "#,
                    task.id
                )
                .execute(&mut *db_pool)
                .await?;
            }
            Err(e) => {
                tracing::error!("Task processing failed: {}", e);
                sqlx::query!(
                    r#"
                    UPDATE pending_tasks
                    SET status = 'failed', error_message = $1
                    WHERE id = $2
                    "#,
                    e.to_string(),
                    task.id
                )
                .execute(&mut *db_pool)
                .await?;
            }
        }
    }
    
    Ok(())
}
```

</examples>

<troubleshooting>

## Common Errors

### Database Connection Issues
- "connection to server was closed" or "connection broken"
  - Cause: Database connection dropped due to timeout or network issue
  - Solution: Use connection pool with appropriate settings and retry logic

- "connection pool has been closed"
  - Cause: Trying to use a database pool that has been dropped
  - Solution: Ensure the pool is properly managed and not dropped prematurely

### Transaction Errors
- "the trait bound `&PgConnection: sqlx::Executor<'_>` is not satisfied"
  - Cause: Using `&*tx` instead of `&mut *tx` with `.execute()`
  - Solution: Always use `&mut *tx` for executing queries

- "error[E0599]: no method named `rollback` found"
  - Cause: Transaction has already been committed or rolled back
  - Solution: Only call `commit()` or `rollback()` once on a transaction

### Async Issues
- "future cannot be sent between threads safely"
  - Cause: Service or resource doesn't implement `Send`
  - Solution: Ensure all types are `Send + Sync` or use proper synchronization

- "future returned by ... is not `Send`"
  - Cause: Using a non-Send future in a context that requires Send
  - Solution: Ensure all futures are `Send` or use proper boxing/wrapping

## Performance Issues
- Database queries taking too long
  - Cause: Missing indexes, complex joins, or inefficient queries
  - Solution: Add appropriate indexes, review query execution plans

- High memory usage
  - Cause: Fetching too many rows at once, storing large datasets in memory
  - Solution: Use pagination, stream results, limit result sets

## Debugging Tips
- Add `#[instrument]` attributes to trace request flow
- Use transaction logging for debugging database issues
- Set up SQL query logging in development
- Check connection pool settings (max_connections, idle_timeout)
- Use database monitoring tools to identify slow queries

</troubleshooting>
